<div style="text-align: center;font-size: xxx-large" >Hypium</div>
<div style="text-align: center">A uint test framework for OpenHarmonyOS application</div>

## Hypium是什么?
***
- Hypium是OpenHarmony上的测试框架，提供测试用例编写、执行、结果显示能力，用于OpenHarmony系统应用接口以及应用界面测试。
- Hypium结构化模型：hypium工程主要由List.test.js与TestCase.test.js组成。
```
rootProject                  // Hypium工程根目录
├── moduleA
│   ├── src
│      ├── main                   // 被测试应用目录
│      ├── ohosTest               // 测试用例目录
│         ├── js/ets
│            └── test
│               └── List.test.js      // 测试用例加载脚本，ets目录下为.ets后缀
│               └── TestCase.test.js  // 测试用例脚本，ets目录下为.ets后缀
└── moduleB
    ...
│               └── List.test.js      // 测试用例加载脚本，ets目录下为.ets后缀
│               └── TestCase.test.js  // 测试用例脚本，ets目录下为.ets后缀
```

## 安装使用
***
- 在DevEco Studio内使用Hypium
- 工程级package.json内配置:
```json
"dependencies": {
    "@ohos/hypium": "1.0.3-rc"
}
```
注：
hypium服务于OpenHarmonyOS应用对外接口测试、系统对外接口测试（SDK中接口），完成HAP自动化测试。详细指导：
<a href = "https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ohos-openharmony-test-framework-0000001263160453" >DevEco Studio</a>

- 通用语法

  测试用例采用业内通用语法，describe代表一个测试套， it代表一条用例。
  
| No.  | API        | 功能说明                                                     |
| ---- | ---------- | ------------------------------------------------------------ |
| 1    | describe   | 定义一个测试套，支持两个参数：测试套名称和测试套函数         |
| 2    | beforeAll  | 在测试套内定义一个预置条件，在所有测试用例开始前执行且仅执行一次，支持一个参数：预置动作函数 |
| 3    | beforeEach | 在测试套内定义一个单元预置条件，在每条测试用例开始前执行，执行次数与it定义的测试用例数一致，支持一个参数：预置动作函数 |
| 4    | afterEach  | 在测试套内定义一个单元清理条件，在每条测试用例结束后执行，执行次数与it定义的测试用例数一致，支持一个参数：清理动作函数 |
| 5    | afterAll   | 在测试套内定义一个清理条件，在所有测试用例结束后执行且仅执行一次，支持一个参数：清理动作函数 |
| 6    | it         | 定义一条测试用例，支持三个参数：用例名称，过滤参数和用例函数 |
| 7    | expect     | 支持bool类型判断等多种断言方法                               |

-  断言库

  示例代码：
  
```javascript
  expect(${actualvalue}).assertX(${expectvalue})
```

  断言功能列表：

| No.  | API              | 功能说明                                                     |
| :--- | :--------------- | ------------------------------------------------------------ |
| 1    | assertClose      | 检验actualvalue和expectvalue(0)的接近程度是否是expectValue(1) |
| 2    | assertContain    | 检验actualvalue中是否包含expectvalue                         |
| 3    | assertEqual      | 检验actualvalue是否等于expectvalue[0]                        |
| 4    | assertFail       | 抛出一个错误                                                 |
| 5    | assertFalse      | 检验actualvalue是否是false                                   |
| 6    | assertTrue       | 检验actualvalue是否是true                                    |
| 7    | assertInstanceOf | 检验actualvalue是否是expectvalue类型                         |
| 8    | assertLarger     | 检验actualvalue是否大于expectvalue                           |
| 9    | assertLess       | 检验actualvalue是否小于expectvalue                           |
| 10   | assertNull       | 检验actualvalue是否是null                                    |
| 11   | assertThrowError | 检验actualvalue抛出Error内容是否是expectValue                |
| 12   | assertUndefined  | 检验actualvalue是否是undefined                               |

  示例代码：

```javascript
  import { describe, it, expect } from '@ohos/hypium'
  export default async function assertCloseTest() {
    describe('assertClose', function () {
      it('assertClose_success', 0, function () {
        let a = 100
        let b = 0.1
        expect(a).assertClose(99, b)
      })
    })
  }
```
-  公共系统能力

| No.  | API                                                     | 功能描述                                                     |
| ---- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 1    | existKeyword(keyword: string, timeout: number): boolean | hilog日志中查找指定字段是否存在，keyword是待查找关键字，timeout为设置的查找时间 |

  示例代码：

```javascript
import { describe, it, expect, SysTestKit} from '@ohos/hypium'

export default function existKeywordTest() {
    describe('existKeywordTest', function () {
        it('existKeyword',DEFAULT, async function () {
            console.info("HelloTest")
            let isExist = await SysTestKit.existKeyword('HelloTest')
            console.info('isExist ------>' + isExist)
        })
    })
}
```
-  专项能力
用例筛选能力：hypium支持根据用例属性筛选执行指定测试用例，使用方式是在测试应用的启动shell命令后新增" -s ${Key} ${Value}"。

| Key  | 含义说明                                                     | Value取值范围                                                |
| ---- | ------------------------------------------------------- | ------------------------------------------------------------ |
| level    | 用例级别      | "0","1","2","3","4" |
| size    | 用例粒度    | "small","medium","large"                         |
| testType    | 用例测试类型      | "function","performance","power","reliability","security","global","compatibility","user","standard","safety","resilience" |

  示例代码

```javascript
import { describe, it, expect, TestType, Size, Level } from '@ohos/hypium'

export default function attributeTest() {
    describe('attributeTest', function () {
        it("testAttributeIt", TestType.FUNCTION | Size.SMALLTEST | Level.LEVEL0, function () {
            console.info('Hello Test')
        })
    })
}
```
### 单元测试框架Mock能力

目前支持函数级mock能力，对定义的函数进行mock后修改函数的行为，使其返回指定的值或者执行某种动作。

#### 约束限制

单元测试框架Mock能力从npm包1.0.1版本开始支持，需修改工程中package.info中配置依赖npm包版本号后使用。

-  **API列表：**

| No. | API | 功能说明 |
| --- | --- | --- |
| 1 |  mockFunc( obj: object, f：founction() |需要mock的函数为某个类对象obj的函数f，那么需要传两个参数：obj和f , 支持使用异步函数（其实对mock来讲都一样，mock并不关注原函数的实现）  |
| 2 | when(mockedfunc：function) | 对传入后方法做检查，检查是否被mock并标记过，返回的是一个方法声明 |
| 3 |afterReturn(x：value) | 设定预期返回一个自定义的值value，比如某个字符串 |
| 4 | afterReturnNothing() | 设定预期没有返回值，即 undefine |
| 5 |  afterAction(x：action) | 设定预期返回一个函数执行的操作，比如返回一个promice |
| 6 |  afterThrow(x：msg) | 设定预期抛出异常，并指定异常msg |
| 7 |  clear() | 用例执行完毕后，进行数据mocker对象的还原处理 |
| 8 |  any | 设定用户传任何类型参数（undefine和null除外），执行的结果都是预期的值 ,先引入ArgumentMatchers类，使用ArgumentMatchers.any方式调用|
| 9 |  anyString | 设定用户传任何字符串参数，执行的结果都是预期的值  ,使用ArgumentMatchers.anyString方式调用|
| 10 |  anyBoolean | 设定用户传任何boolean类型参数，执行的结果都是预期的值  ,使用ArgumentMatchers.anyBoolean方式调用|
| 11 |  anyFounction | 设定用户传任何function类型参数，执行的结果都是预期的值  ,使用ArgumentMatchers.anyFounction方式调用|
| 12 | anyNumber | 设定用户传任何数字类型参数，执行的结果都是预期的值  ,使用ArgumentMatchers.any方式调用|
| 13 | anyObj | 设定用户传任何对象类型参数，执行的结果都是预期的值  ,使用ArgumentMatchers.anyObj方式调用|
| 14 | matchRegexs(Regex) | 设定用户传任何正则表达式类型参数Regex，执行的结果都是预期的值  ,使用ArgumentMatchers.matchRegexs(Regex)方式调用|
| 15 |  verify(methodName, argsArray) | 验证methodName（函数名字符串）所对应的函数和其参数列表argsArray的执行 行为是否符合预期，返回一个 VerificationMode：一个提供验证模式的类，它有times(count),once(),atList(x),atMost(x)等等函数可供选择|
| 16 |  times(count) | 验证行为调用过count次 |
| 17 | once() | 验证行为调用过一次 |
| 18 | atLeast(count) | 验证行为至少调用过count次 |
| 19 | atMost(count) |  验证行为至多调用过count次 |
| 20 | never |  验证行为从未发生过 |
| 21 | ignoreMock(obj, method) | 使用ignoreMock可以还原obj对象中被mock后的函数，对被mock后的函数有效 |
| 22 |  clearAll() | 用例执行完毕后，进行数据和内存清理 |

-  **使用示例：**

用户可以通过一下方式进行引入mock模块进行测试用例编写：

```javascript
//必须引入的mock能力模块api: MockKit, when等
//根据自己用例需要引入断言能力api
import { describe, expect, it, MockKit, when } from '@ohos/hypium'
```
**示例1：afterReturn 的使用**

```javascript
import { describe, expect, it, MockKit, when } from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }

                method_2() {
                    return '999999'
                }
            }

            let claser = new ClassName();

            //3.进行mock操作,比如需要对ClassName类的method_1函数进行mock
            let mockfunc = mocker.mockFunc(claser,claser.method_1);
            when(mockfunc)('test').afterReturn('1');

            //4.对mock后的函数进行断言，看是否符合预期
            //执行成功案例，参数为'test'
            expect(claser.method_1('test')).assertEqual('1');//执行通过
            
            //执行失败案例，参数为 'abc'
            //expect(claser.method_1('abc')).assertEqual('1');//执行失败
        })
    })
}
```
- **特别注意：**
`when(mockfunc)('test').afterReturn('1');`
这句代码中的`('test')`是mock后,类对象的函数需要传递的匹配参数，目前支持一个参数
`afterReturn('1')`是用户需要预期返回的结果。
有且只有在参数是`('test')`的时候，执行的结果才是用户自定义的预期结果。

**示例2： afterReturnNothing 的使用**

```javascript
import { describe, expect, it, MockKit, when } from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }

                method_2() {
                    return '999999'
                }
            }

            let claser = new ClassName();

            //3.进行mock操作,比如需要对ClassName类的method_1函数进行mock
            let mockfunc = mocker.mockFunc(claser,claser.method_1);
            
            //4.根据自己需求进行选择 执行完毕后的动作，比如这里我选择afterReturnNothing();即不返回任何值
            when(mockfunc)('test').afterReturnNothing();

            //5.对mock后的函数进行断言，看是否符合预期，注意选择跟第4步中对应的断言方法
           
             //执行成功案例，参数为'test'，这时候 我们执行原对象claser.method_1的方法，会发生变化
             // 这时候执行的claser.method_1不会再返回'888888'，而是我们设定的afterReturnNothing()生效//不返回任何值;
            expect(method_1('test')).assertUndefined();//执行通过
            
            // 执行失败案例，参数传为 123
            // expect(method_1(123)).assertUndefined();//执行失败
        })
    })
```

**示例3： 设定参数类型为any ，即接受任何参数（undefine和null除外）的使用**

```javascript
//注意需要引入ArgumentMatchers类，即参数匹配器，any系列同理
import {any} from '@ohos/hypium/src/module/mock/ArgumentMatchers'
```


```javascript
import { describe, expect, it, MockKit, when, ArgumentMatchers} from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }

                method_2() {
                    return '999999'
                }
            }

            let claser = new ClassName();

            //3.进行mock操作,比如需要对ClassName类的method_1函数进行mock
            let mockfunc = mocker.mockFunc(claser,claser.method_1);
            //根据自己需求进行选择参数匹配器和预期方法,
            when(mockfunc)(ArgumentMatchers.any).afterReturn('1');
            
            //4.对mock后的函数进行断言，看是否符合预期，注意选择跟第4步中对应的断言方法
            //执行成功的案例1，传参为字符串类型
            expect(claser.method_1('test')).assertEqual('1');//用例执行通过。
             //执行成功的案例2，传参为数字类型123
            //expect(claser.method_1(123)).assertEqual('1');//用例执行通过。
             //执行成功的案例3，传参为boolean类型true
            //expect(claser.method_1(true)).assertEqual('1');//用例执行通过。
            
            //执行失败的案例，传参为数字类型空
            //expect(claser.method_1()).assertEqual('1');//用例执行失败。
        })
    })
```

**示例4： 设定参数类型为anyString,anyBoolean等 的使用**
```javascript
import { describe, expect, it, MockKit, when, ArgumentMatchers} from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }

                method_2() {
                    return '999999'
                }
            }

            let claser = new ClassName();

            //3.进行mock操作,比如需要对ClassName类的method_1函数进行mock
            let mockfunc = mocker.mockFunc(claser,claser.method_1);
            //根据自己需求进行选择 
            when(mockfunc)(ArgumentMatchers.anyString).afterReturn('1');
            
            //4.对mock后的函数进行断言，看是否符合预期，注意选择跟第4步中对应的断言方法
            //执行成功的案例，传参为字符串类型
            expect(claser.method_1('test')).assertEqual('1');//用例执行通过。
            
            //执行失败的案例，传参为数字类型
            //expect(claser.method_1(123)).assertEqual('1');//用例执行失败。
        })
    })
```

**示例5： 设定参数类型为matchRegexs（Regex）等 的使用**
```javascript
import { describe, expect, it, MockKit, when, ArgumentMatchers} from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }

                method_2() {
                    return '999999'
                }
            }

            let claser = new ClassName();

            //3.进行mock操作,比如需要对ClassName类的method_1函数进行mock
            let mockfunc = mocker.mockFunc(claser,claser.method_1);
            //根据自己需求进行选择，这里假设匹配正则，且正则为/123456/
            when(mockfunc)(ArgumentMatchers.matchRegexs(/123456/)).afterReturn('1');
            
            //4.对mock后的函数进行断言，看是否符合预期，注意选择跟第4步中对应的断言方法
            //执行成功的案例，传参为字符串 比如 '1234567898'
            //expect(claser.method_1('1234567898')).assertEqual('1');//用例执行通过。
            //因为字符串 '1234567898'可以和正则/123456/匹配上
            
            //执行失败的案例，传参为字符串'1234'
            //expect(claser.method_1('1234')).assertEqual('1');//用例执行失败。反之
        })
    })
```

**示例6： 验证功能 Verify函数的使用**
```javascript
import { describe, expect, it, MockKit, when } from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }

                method_2() {
                    return '999999'
                }
            }

            let claser = new ClassName();

            //3.进行mock操作,比如需要对ClassName类的method_1和method_2两个函数进行mock
            mocker.mockFunc(claser,claser.method_1);
            mocker.mockFunc(claser,claser.method_2);
            
            //4.我们来做一些调用，如下
             claser.method_1('abc','ppp');
             claser.method_1('abc');
             claser.method_1('xyz');
             claser.method_1();
             claser.method_1('abc','xxx','yyy');
             claser.method_1();
             claser.method_2('111');
             claser.method_2('111','222');
            
            //5.现在对mock后的两个函数进行验证，验证他们的调用情况 
             mocker.verify('method_1',[]).atLeast(3);//结果为failed
             //解释：验证函数'method_1'，参数列表为空：[] 的函数，至少执行过3次，
             //执行结果为failed，因为'method_1'且无参数 在4中只执行过2次
             
             //mocker.verify('method_2',['111']).once();//执行success，原因同上
             
             //mocker.verify('method_2',['111',,'222']).once();//执行success，原因同上
        })
    })
```

**示例7：  ignoreMock(obj, method) 忽略函数的使用**
```javascript
import { describe, expect, it, MockKit, when, ArgumentMatchers} from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }

                method_2() {
                    return '999999'
                }
            }

            let claser = new ClassName();
            
            
            //3.进行mock操作,比如需要对ClassName类的method_1和method_2两个函数进行mock
            let func_1 = mocker.mockFunc(claser,claser.method_1);
            let func_2 = mocker.mockFunc(claser,claser.method_2);
            
            //4.对mock后的函数的行为进行修改
            when(func_1)(ArgumentMatchers.anyNumber).afterReturn('4');
            when(func_2)(ArgumentMatchers.anyNumber).afterReturn('5');

            //5.我们来做一些调用，如下
             console.log(claser.method_1('abc','ppp')) ;//执行结果是4，符合步骤4中的预期
             console.log(claser.method_2('111'));//执行结果是5，符合步骤4中的预期
            
            //6.现在对mock后的两个函数的其中一个函数method_1进行忽略处理（原理是就是还原）
             mocker.ignoreMock(claser,claser.method_1);
            //然后再去调用 claser.method_1函数，看执行结果
             console.log(claser.method_1('abc','ppp'));//执行结果是888888，发现这时结果跟步骤4中的预期不一样了，执行了claser.method_1没被mock之前的结果
             
             claser.method_2('111');//执行结果是5，因为method_2没有执行ignor忽略，所有也符合步骤4中的预期
            
        })
    })
```

**示例7：  clear（）函数的使用**

```javascript
import { describe, expect, it, MockKit, when, ArgumentMatchers} from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }

                method_2() {
                    return '999999'
                }
            }

            let claser = new ClassName();
            
            
            //3.进行mock操作,比如需要对ClassName类的method_1和method_2两个函数进行mock
            let func_1 = mocker.mockFunc(claser,claser.method_1);
            let func_2 = mocker.mockFunc(claser,claser.method_2);
            
            //4.对mock后的函数的行为进行修改
            when(func_1)(ArgumentMatchers.anyNumber).afterReturn('4');
            when(func_2)(ArgumentMatchers.anyNumber).afterReturn('5');

            //5.我们来做一些调用，如下
             console.log(claser.method_1('abc','ppp')) ;//执行结果是4，符合步骤4中的预期
             console.log(claser.method_2('111'));//执行结果是5，符合步骤4中的预期
            
            //6.清除mock操作（原理是就是还原）
             mocker.clear(claser);
            //然后再去调用 claser.method_1函数，看执行结果
             console.log(claser.method_1('abc','ppp'));//执行结果是888888，发现这时结果跟步骤4中的预期不一样了，执行了claser.method_1没被mock之前的结果
             console.log(claser.method_2('abc','ppp'));//执行结果是999999，发现这时结果跟步骤4中的预期不一样了，执行了claser.method_2没被mock之前的结果 
        })
    })
```


**示例8：  afterThrow(msg) 函数的使用**

```javascript
import { describe, expect, it, MockKit, when } from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                method_1() {
                    return '888888'
                }
            }

            let claser = new ClassName();

            //3.进行mock操作,比如需要对ClassName类的method_1函数进行mock
            let mockfunc = mocker.mockFunc(claser,claser.method_1);
            
            //4.根据自己需求进行选择 执行完毕后的动作，比如这里我选择afterReturnNothing();即不返回任何值
            when(mockfunc)('test').afterThrow('error xxx');

            //5.执行mock后的函数，捕捉异常并使用assertEqual对比msg否符合预期
             try {
                    claser.method_1('test');
                } catch (e) {
                     expect(e.message).assertEqual('error xxx');//执行通过
                }
        })
    })
```

**示例9：  mock异步 函数的使用**

```javascript
import { describe, expect, it, MockKit, when } from '@ohos/hypium'

export default function ActsAbilityTest() {
    describe('ActsAbilityTest', function () {
        it('testMockfunc', 0, function () {
            console.info("it1 begin");
            
            //1.创建一个mock能力的对象MockKit
            let mocker = new MockKit();
            
            //2.定类ClassName，里面两个函数，然后创建一个对象claser
           class ClassName {
                constructor() {
                }

                async method_1() {
                    return new Promise((res,rej)=>{
                        //做一些异步操作
                            setTimeout(function(){
                                console.log('执行');
                                resolve('数据传递');
                            }, 2000);
                        })
                }
            }

            let claser = new ClassName();

            //3.进行mock操作,比如需要对ClassName类的method_1函数进行mock
            let mockfunc = mocker.mockFunc(claser,claser.method_1);
            
            //4.根据自己需求进行选择 执行完毕后的动作，比如这里我选择afterRetrun; 可以自定义返回一个promise
            when(mockfunc)('test').afterRetrun(new Promise((res,rej)=>{
                console.log("do something");
            }));

            //5.执行mock后的函数，即对定义的promise进行后续执行
            claser.method_1('test').then(function(data){
                    //数据处理代码...
                    console.log(data);
                });
    })
```

## 约束
***
    本模块首批接口从OpenHarmony SDK API version 8开始支持。

## Hypium开放能力隐私声明

-  我们如何收集和使用您的个人信息
	您在使用集成了Hypium开放能力的测试应用时，Hypium不会处理您的个人信息。
-  SDK处理的个人信息
	不涉及。
-  SDK集成第三方服务声明
	不涉及。
-  SDK数据安全保护
	不涉及。
-  SDK版本更新声明
	为了向您提供最新的服务，我们会不时更新Hypium版本。我们强烈建议开发者集成使用最新版本的Hypium。


